{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to The Data Science Class","text":""},{"location":"#introduction","title":"Introduction","text":"<p>In this class, we will explore the fundamental concepts and techniques used in the field of data science, including statistical analysis, machine learning, data visualization, and more. You will learn how to extract insights and make predictions from large and complex datasets using a variety of tools and techniques. Whether you are new to the field or have some experience, this class will provide you with the skills and knowledge you need to succeed as a data scientist. </p>"},{"location":"#what-is-data-science","title":"What is Data Science","text":"<p>Data science is an interdisciplinary field that uses scientific methods, processes, algorithms and systems to extract knowledge and insights from structured and unstructured data. It involves the use of various techniques and tools such as machine learning, statistical analysis, and visualization to extract useful information and insights from data. This information can then be used to make decisions, predictions, or to inform research.</p> <p></p> <p>Data science is used in a wide range of fields such as finance, healthcare, retail, marketing, transportation, and many more. It has become increasingly important as the amount of data generated by modern technology continues to grow.</p> <p></p> <p></p>"},{"location":"#planning-of-the-course","title":"Planning of the course","text":"<ul> <li> <p>Python Programming : Python's simplicity, readability, and the availability of powerful libraries and modules make it a great choice for data science tasks, from data manipulation and analysis to building and deploying machine learning models.</p> </li> <li> <p>Data Base Management System : In data science, it is often necessary to work with large amounts of data that are stored in databases. Database management systems (DBMS) provide a way to organize, store, and retrieve data in an efficient and organized way.</p> </li> <li> <p>R Programming : R is particularly useful for data analysis in fields such as genomics, finance, and social sciences.</p> </li> <li> <p>Exploratory Data Analysis : Is an essential step in the data science process. It is the process of analyzing and summarizing the main characteristics of a data set, and is used to uncover patterns, trends, and relationships within the data. EDA helps data scientists to understand the data they are working with, identify any potential issues or biases, and select the appropriate statistical techniques to use for further analysis. It also helps to create a solid foundation for building models and making predictions. </p> </li> <li> <p>Machine Learning :  It is a branch of artificial intelligence based on the idea that systems can learn from data, identify patterns and make decisions with minimal human intervention. Machine learning focuses on the development of algorithms and statistical models that enable computers to learn from and make predictions or decisions without being explicitly programmed to perform the task</p> </li> <li> <p>Deep Learning : Deep learning is a subfield of machine learning that is inspired by the structure and function of the brain, specifically the neural networks. It involves training large artificial neural networks to perform tasks such as image and speech recognition, natural language processing, and decision making. These neural networks are trained using large amounts of data and are able to learn and improve over time. Deep learning has achieved state-of-the-art results in many areas and has revolutionized the field of artificial intelligence. It is widely used in applications such as computer vision, natural language processing, and self-driving cars.</p> </li> <li> <p>AI models Deployement : AI models deployments refer to the process of taking a trained AI model and making it available for use in a production environment. This can include things like scaling the model to handle large amounts of data, integrating the model with other systems and software, and monitoring the performance of the model in a live setting.</p> </li> <li> <p>Data Visualization using Tableau/Power Bi : Data visualization is the process of creating graphical representations of data in order to effectively communicate insights and findings. Tableau and Power BI are both popular tools used for data visualization. They offer a wide range of interactive visualizations, including maps, charts, and dashboards</p> </li> <li> <p>Capstone Project : The project is designed to apply the knowledge and skills that students have learned throughout the program. It is typically a hands-on, real-world project that requires students to use data science techniques and tools to solve a problem or answer a research question. The project can be based on any topic that is relevant to data science and can include tasks such as data collection, cleaning, exploration, analysis, modeling, and visualization.</p> </li> </ul> <p></p> <p>Let's get started!</p>"},{"location":"basic/","title":"Basic Python Concepts","text":""},{"location":"basic/#basic-python-concepts","title":"Basic Python Concepts","text":""},{"location":"basic/#variables","title":"Variables","text":"<p>Variables are used to store values in Python. They are like containers that hold data, and you can use them to perform operations on that data. Variables are declared using the assignment operator (=) and can be of different types, such as integers, floating-point numbers, strings, and more.</p> <pre><code># Example of variable assignment\nx = 5\ny = \"Hello World\"\nz = [1, 2, 3]\n</code></pre>"},{"location":"basic/#data-types-and-structures","title":"Data types and structures","text":"<p>Python supports several built-in data types, such as integers, floating-point numbers, strings, lists, tuples, and dictionaries. Each data type has its own set of characteristics and methods.</p> <pre><code># Example of different data types\nx = 5 # integer\ny = 3.14 # floating-point number\nz = \"Hello World\" # string\na = [1, 2, 3] # list\nb = (4, 5, 6) # tuple\nc = {\"name\": \"John\", \"age\": 30} # dictionary\n</code></pre>"},{"location":"basic/#operators","title":"Operators","text":"<p>Python supports various types of operators, such as arithmetic operators (+, -, x , /, %), comparison operators (&gt;, &lt;, &gt;=, &lt;=, ==, !=), and logical operators (and, or, not). These operators are used to perform different types of operations on variables and data.</p> <pre><code># Example of operators\nx = 5\ny = 2\n\n# arithmetic operators\nprint(x + y) # 7\nprint(x - y) # 3\nprint(x * y) # 10\nprint(x / y) # 2.5\nprint(x % y) # 1\n\n# comparison operators\nprint(x == y) # False\nprint(x &gt; 2) # True\n\n# logical operators \nprint(x == y and x &gt; 2) # False\nprint(x == y or x &gt; 2) # True\n</code></pre>"},{"location":"basic/#control-flow","title":"Control flow","text":"<p>Control flow or Conditional Statements allows us to control the flow of execution of our program based on certain conditions. For example : </p> <ul> <li>if-elif-else statements </li> </ul> <pre><code>x = 5\nif x &gt; 0:\n    print(\"x is positive\")\nelif x &lt; 0:\n    print(\"x is negative\")\nelse:\n    print(\"x is zero\")\n</code></pre> <ul> <li>for loop</li> </ul> <pre><code>for i in range(5):\n    print(i)\n</code></pre> <ul> <li>while loop  </li> </ul> <pre><code>x = 5\nwhile x &gt; 0:\n    print(x)\n    x -= 1\n</code></pre>"},{"location":"basic/#functions","title":"Functions","text":"<p>Functions are a way to group together a set of instructions to perform a specific task. Functions are defined using the def keyword and can take input arguments and return output values.</p> <pre><code>def add(x, y):\n    return x + y\n\nresult = add(5, 2)\nprint(result) # 7\n</code></pre>"},{"location":"basic/#modules-and-libraries","title":"Modules and Libraries","text":"<p>Python has a large number of built-in modules and libraries that provide a wide range of functionality. You can use these modules to perform various tasks, such as working with the file system, performing mathematical calculations, and more.</p> <pre><code># Example of importing a module\nimport math\n\nresult = math.sqrt(16)\nprint(result) # 4.0\n\n# Example of importing a specific function from a module\nfrom math import sqrt\n\nresult = sqrt(16)\nprint(result) # 4.0\n</code></pre>"},{"location":"basic/#exception-handling","title":"Exception Handling","text":"<p>Python supports exception handling, which allows you to handle errors and exceptions that may occur while running your program. This helps you to write robust code that can handle unexpected situations</p> <pre><code>while True:\n    try:\n        x = int(input(\"Please enter a number: \"))\n        y = int(input(\"Please enter another number: \"))\n        print(\"The result of x/y is:\", x/y)\n        break\n    except ValueError:\n        print(\"Oops! One of the inputs was not a valid number. Try again...\")\n    except ZeroDivisionError:\n        print(\"Oops! You cannot divide by zero. Try again...\")\n</code></pre> <p>In this example, program will handle two types of exception: ValueError and ZeroDivisionError, as the user input may not be valid number and also user may try to divide by zero.</p> <p></p> <p>Now, let's code ! </p>"},{"location":"basic/#things-to-remember","title":"Things to Remember","text":"<ul> <li> <p>Case Sensitivity: Python is a case-sensitive language, so be mindful of the case when naming variables, functions, and classes. This means, Variable and variable are not the same.</p> </li> <li> <p>Each variable, function and class should have a unique name within your code</p> </li> <li> <p>The only variables you need to consider inside your function are the arguments of that function</p> </li> <li> <p>Always give the identifiers a name that makes sense. While c = 10 is a valid name, writing count = 10 would make more sense, and it would be easier to figure out what it represents when you look at your code after a long gap.</p> </li> <li> <p>Multiple words can be separated using an underscore, like this_is_a_long_variable.</p> </li> <li> <p>Comments: Use the pound symbol (#) to denote comments in your code, which will be ignored by the interpreter. In computer programming, comments are hints that we use to make our code more understandable. </p> </li> <li> <p>Quotation Marks: In Python, you can use either single quotes or double quotes to denote strings, but be consistent within your code.</p> </li> <li> <p>Colon (:): Colons are used to denote the start of a new block of code, such as in a for loop, if statement, or function definition.</p> </li> <li> <p>White Space: Be mindful of white space, as it can affect the way your code is interpreted. For example, leading white space is used to denote blocks of code.</p> </li> <li> <p>Parentheses: Parentheses are used to group expressions, to call functions, and to define tuples.</p> </li> <li> <p>Import Statement: Use the import statement to import libraries and modules into your code.</p> </li> <li> <p>print() function: Use the print() function to output text to the console.</p> </li> </ul>"},{"location":"env/","title":"Setting up a Development Environment","text":""},{"location":"env/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":""},{"location":"env/#introduction","title":"Introduction","text":"<p>In this chapter, you will learn how to set up a Python development environment on your computer. A development environment is a software application that provides the necessary tools and resources for writing, testing, and debugging code. By the end of this chapter, you will have a working Python environment that you can use to start writing your own programs.</p>"},{"location":"env/#installing-python","title":"Installing Python","text":"<p>There are several ways to install Python 3, here are some of the most common methods:</p>"},{"location":"env/#using-anaconda","title":"Using Anaconda","text":"<p>Anaconda is a popular distribution of Python and R for data science and machine learning. It comes with a lot of packages and libraries pre-installed, and it also includes the conda package manager, which makes it easy to install additional packages and manage environments. To install Python using Anaconda, you can follow these steps:</p> <ul> <li>Go to the Anaconda Website and download the latest version of Anaconda for your operating system.</li> <li>Once the download is complete, run the installer and follow the prompts to install Anaconda.</li> <li>Once installation is complete, open Anaconda Navigator, which is a graphical user interface that allows you to manage your environments and packages.</li> <li>Create a new environment with Python 3 by clicking the \"Create\" button and selecting \"Python 3\" as the version.</li> </ul>"},{"location":"env/#using-pip","title":"Using pip","text":"<p>pip is the package installer for Python. It allows you to install and manage packages for your Python installation. To install Python 3 and Jupyter Notebook using pip, you can follow these two steps:</p> <ul> <li> <p>Make sure that Python 3 is installed on your system by running the command <code>python3 --version</code> in a terminal or command prompt.</p> </li> <li> <p>If Python 3 is not installed, download the latest version from The Official Python Website.</p> </li> </ul>"},{"location":"env/#using-homebrew-macos-and-linux","title":"Using Homebrew (macOS and Linux)","text":"<p>Homebrew is a package manager for macOS and Linux. It allows you to install and manage packages for your operating system. To install Python 3 using Homebrew, you can follow these steps:</p> <ul> <li>Make sure that Homebrew is installed on your system by running the command <code>brew --version</code> in a terminal.</li> <li>If Homebrew is not installed, you can install it by following the instructions on The Homebrew Website.</li> <li>Once you have Homebrew installed, you can use it to install Python 3 by running the command <code>brew install python3</code> in a terminal.</li> </ul>"},{"location":"env/#using-chocolatey-windows","title":"Using Chocolatey (Windows)","text":"<p>Chocolatey is a package manager for Windows. It allows you to install and manage packages for your operating system. To install Python 3 using Chocolatey, you can follow these steps:</p> <ul> <li>Make sure that Chocolatey is installed on your system by running the command <code>choco --version</code> in a command prompt.</li> <li> <p>If Chocolatey is not installed, you can install it by following the instructions on The Chocolatey Website.</p> </li> <li> <p>Once you have Chocolatey installed, you can use it to install Python 3 by running the command <code>choco install python</code> in a command prompt.</p> </li> </ul> <p>PS : It's also worth noting that many operating systems and Linux distributions come with Python 2 pre-installed, and you may want to install Python 3 alongside it without replacing the pre-installed Python 2. In this case, you should be careful when running pip and python commands, since you may need to use pip3 and python3, respectively, to ensure that you're using the correct version of the software.</p>"},{"location":"env/#choosing-an-ide-or-text-editor","title":"Choosing an IDE or Text Editor","text":"<p>Once you have Python installed, the next step is to choose a text editor or integrated development environment (IDE) to write your code in. An IDE is a software application that provides a comprehensive environment for coding, including features such as syntax highlighting, code completion, and debugging tools. In this class we're using Jupyter. Jupyter is an open-source web-based IDE that allows users to create and share documents that contain live code, equations, visualizations, and narrative text. It is particularly well-suited for data science because it:</p> <ul> <li> <p>Provides an easy way to interact with data: Jupyter allows you to load, visualize, and manipulate data in a variety of formats, such as CSV, JSON, and SQL. This makes it a great tool for data exploration and analysis.</p> </li> <li> <p>Supports multiple programming languages: Jupyter supports many programming languages, including Python, R, and Julia, which makes it easy to use the language that is best suited for your project.</p> </li> <li> <p>Enables reproducible research: Jupyter allows you to organize your code, data, and visualizations in a single document, which makes it easy to reproduce your results and share your work with others.</p> </li> <li> <p>Provides a collaborative environment: Jupyter allows multiple users to work on the same notebook at the same time, which makes it a great tool for collaborative data science projects.</p> </li> <li> <p>Has a large and active community: Jupyter has a large and active community of developers, users, and contributors who provide support, resources, and add-ons that extend its functionality.</p> </li> </ul> <p>To install Jupyter:</p> <ul> <li> <p>Using Anaconda: In your conda enviroment you can install Jupyter Notebook by running the command <code>conda install jupyter</code>. </p> </li> <li> <p>Using pip3: You can install Jupyter using the pip package manager by running the command <code>pip3 install jupyter</code> in your command line. This method requires that you have Python3 and pip3 already installed on your system.</p> </li> </ul> <p>You can then launch Jupyter Notebook by running the command jupyter notebook in a terminal or command prompt.</p> <p></p> <p></p> <p></p> <p>Some popular IDEs for Python include PyCharm, Spyder, and IDLE. Text editors, such as Sublime Text, Atom, or Notepad++, are also popular among Python developers and are preferred by some. I suggest you Install Sublime Text as a second IDE.</p>"},{"location":"env/#installing-additional-libraries-and-packages","title":"Installing Additional Libraries and Packages","text":"<p>Python has a vast collection of libraries and packages that can be used to perform a wide range of tasks. Some popular packages include NumPy and Pandas for data manipulation, Matplotlib and Seaborn for data visualization, and scikit-learn for machine learning. You can install these packages using the pip package manager, which is included with Python.</p> <p></p> <p>Examples : </p> <ul> <li><code>pip3 install numpy</code></li> <li><code>pip3 install pandas</code></li> </ul>"},{"location":"env/#conclusion","title":"Conclusion","text":"<p>By the end of this chapter, you should have a working Python development environment that you can use to start writing your own programs. You will have a Python interpreter, a text editor or IDE, and any additional libraries and packages that you need. In the next chapter, you will learn the basics of Python programming, including data types, variables, and operators.</p>"},{"location":"intro/","title":"Introduction to Python Programming","text":""},{"location":"intro/#introduction-to-python-programming","title":"Introduction to Python Programming","text":"<p>Python is a powerful, high-level programming language that is widely used for web development, data analysis, machine learning, and scientific computing. Its simple, easy-to-read syntax and versatile libraries make it a popular choice for beginners and experienced programmers alike. </p> <p></p> <p>In this course, you will learn the basics of Python programming, including data types, variables, operators, control flow, and functions. You will also explore advanced topics such as data structures, working with data, data visualization, and machine learning. Along the way, you will gain hands-on experience through a variety of exercises and a final project.</p> <p></p> <p>By the end of this course, you will have a solid foundation in Python programming, and the skills to apply it to a wide range of data science and other applications.</p>"},{"location":"intro/#various-recources-for-you-to-practice","title":"Various Recources for you to practice","text":"<ul> <li> <p>Codecademy's Learn Python Track: This interactive course covers all the basics of Python and includes exercises to practice what you've learned.</p> </li> <li> <p>HackerRank's Python Domain: This website offers a wide range of Python coding challenges, from beginners to advanced levels.</p> </li> <li> <p>Python.org's Beginner's Guide: This guide provides a gentle introduction to Python, including tutorials and exercises for beginners.</p> </li> <li> <p>Google's Python Class: This free class, taught by Google engineer Nick Parlante, includes video lectures, slides, and exercises.</p> </li> <li> <p>Full Stack Python : Is a website that provides resources and tutorials on various aspects of the Python programming language, with a focus on web development and data science. Additionally, the website provides a curated list of resources for further learning and a podcast discussing all things Python.</p> </li> <li> <p>Code Signal : Is a website and platform that provides a variety of tools and resources for developers, including a code editor, a test runner, and a code execution environment. It also provides a variety of challenges and assessments to help developers improve their coding skills. </p> </li> </ul>"},{"location":"io/","title":"File Input/Output (I/O) Operations","text":""},{"location":"io/#introduction","title":"Introduction","text":"<p>File Input/Output (I/O) operations in Python allow you to read from and write to files on your local file system. The open function is the main function used for working with files in Python, and it returns a file object that can be used to perform various operations on the file.</p>"},{"location":"io/#opening-a-file","title":"Opening a File","text":"<p>The basic syntax for opening a file in Python is as follows:</p> <pre><code>file = open(\"filename.extension\", \"mode\")\n</code></pre> <p>The first argument is the name of the file, and the second argument is the mode in which you want to open the file. The most common modes are \"r\" for reading, \"w\" for writing, and \"a\" for appending.</p> <p></p> <p>For example, to open a text file called example.txt in read mode, you would write the following code:</p> <pre><code>file = open(\"example.txt\", \"r\")\n</code></pre>"},{"location":"io/#reading-from-a-file","title":"Reading from a File","text":"<p>Once you have opened a file, you can read from it using various methods, such as read, readline, and readlines.</p> <p></p> <p>The read method reads the entire contents of a file as a single string. For example:</p> <pre><code>file = open(\"example.txt\", \"r\")\ncontents = file.read()\nprint(contents)\nfile.close()\n</code></pre> <p>The readline method reads a single line of a file. For example:</p> <pre><code>file = open(\"example.txt\", \"r\")\nfirst_line = file.readline()\nprint(first_line)\nfile.close()\n</code></pre> <p>The readlines method reads all lines of a file as a list of strings, where each string is a single line. For example:</p> <pre><code>file = open(\"example.txt\", \"r\")\nlines = file.readlines()\nprint(lines)\nfile.close()\n</code></pre>"},{"location":"io/#writing-to-a-file","title":"Writing to a File","text":"<p>To write to a file, you can use the write method. The basic syntax for writing to a file is as follows:</p> <pre><code>file = open(\"filename.extension\", \"mode\")\nfile.write(\"data to be written\")\nfile.close()\n</code></pre> <p>For example, to write the string \"Hello, World!\" to a file called example.txt, you would write the following code:</p> <pre><code>file = open(\"example.txt\", \"w\")\nfile.write(\"Hello, World!\")\nfile.close()\n</code></pre> <p>If the file specified in the open function does not exist, it will be created. If the file does exist, its contents will be overwritten by the new data.</p>"},{"location":"io/#appending-to-a-file","title":"Appending to a File","text":"<p>To append data to an existing file, you can open the file in append mode (\"a\") instead of write mode (\"w\"). The basic syntax for appending to a file is as follows:</p> <pre><code>file = open(\"filename.extension\", \"mode\")\nfile.write(\"data to be written\")\nfile.close()\n</code></pre> <p>For example, to append the string \"Hello, World!\" to a file called example.txt, you would write the following code:</p> <pre><code>file = open(\"example.txt\", \"a\")\nfile.write(\"Hello, World!\")\nfile.close()\n</code></pre>"},{"location":"io/#context-manager","title":"Context Manager","text":"<p>One important thing to note when working with files in Python is that you should always close the file when you are done with it. This can be done using the close method, as demonstrated in the previous examples. However, there is a better way to ensure that the file is always closed, even if an error occurs, and that is by using a context manager.</p> <p></p> <p>A context manager is an object that provides a convenient way to manage resources, such as files, that need to be cleaned up after they are used. In Python, the with statement is used to create a context manager. The basic syntax for using a context manager to open a file is as follows:</p> <pre><code>with open(\"filename.extension\", \"mode\") as file:\n    # Perform file I/O operations\n</code></pre> <p>For example, to read the contents of a file called example.txt using a context manager, you would write the following code:</p> <pre><code>with open(\"example.txt\", \"r\") as file:\n    contents = file.read()\n    print(contents)\n</code></pre> <p>With this approach, the file is automatically closed when the with block is exited, even if an error occurs.</p>"},{"location":"io/#csv-library","title":"CSV Library","text":""},{"location":"io/#reading-data-from-a-csv-file","title":"Reading data from a CSV file","text":"<p>To read data from a CSV file, you can use the csv.reader function. This function returns an iterator that you can loop over to access the rows of the CSV file. Here is an example:</p> <pre><code>import csv\n\nwith open('my_file.csv', 'r') as csv_file:\n    csv_reader = csv.reader(csv_file)\n\n    # Loop over each row in the CSV file\n    for row in csv_reader:\n        # Access the values of each row\n        print(row)\n</code></pre> <p>This code opens the my_file.csv file in read mode and creates a csv.reader object using the csv.reader function. Then, it loops over each row in the CSV file and prints out the values of each row.</p>"},{"location":"io/#writing-data-to-a-csv-file","title":"Writing data to a CSV file","text":"<p>To write data to a CSV file, you can use the csv.writer function. This function takes a file object and returns a writer object that you can use to write rows to the CSV file. Here is an example:</p> <pre><code>import csv\n\nwith open('my_file.csv', 'w', newline='') as csv_file:\n    csv_writer = csv.writer(csv_file)\n\n    # Write rows to the CSV file\n    csv_writer.writerow(['Title', 'Author', 'Publisher'])\n    csv_writer.writerow(['To Kill a Mockingbird', 'Harper Lee', 'Grand Central Publishing'])\n</code></pre> <p>This code opens the my_file.csv file in write mode and creates a csv.writer object using the csv.writer function. Then, it writes two rows to the CSV file.</p>"},{"location":"io/#appending-data-to-a-csv-file","title":"Appending data to a CSV file","text":"<p>To append data to a CSV file, you can use the csv.writer function with the a mode. This mode will open the file in append mode, which allows you to add new rows to the end of the file. Here is an example:</p> <pre><code>import csv\n\nwith open('my_file.csv', 'a', newline='') as csv_file:\n    csv_writer = csv.writer(csv_file)\n\n    # Append rows to the CSV file\n    csv_writer.writerow(['1984', 'George Orwell', 'Signet Classic'])\n</code></pre> <p>This code opens the my_file.csv file in append mode and creates a csv.writer object using the csv.writer function. Then, it appends a new row to the end of the CSV file.</p>"},{"location":"io/#removing-data-from-a-csv-file","title":"Removing data from a CSV file","text":"<p>To remove data from a CSV file, you will need to read in the entire file, filter out the rows that you don't want, and then write the filtered rows back to the CSV file. Here is an example:</p> <pre><code>import csv\n\n# Read in the CSV file and filter out the rows that match a specific criteria\nwith open('my_file.csv', 'r') as csv_file:\n    csv_reader = csv.reader(csv_file)\n\n    filtered_rows = []\n    for row in csv_reader:\n        if row[1] != 'Harper Lee':\n            filtered_rows.append(row)\n\n# Write the filtered rows back to the CSV file\nwith open('my_file.csv', 'w', newline='') as csv_file:\n    csv_writer = csv.writer(csv_file)\n\n    for row in filtered_rows:\n        csv_writer.writerow(row)\n</code></pre> <p>This code reads in the my_file.csv file and filters out the rows where the author is \"Harper Lee\". Then, it opens the same file in write mode and writes the filtered rows back to the CSV file.</p>"},{"location":"numpy/","title":"NumPy","text":"<p>NumPy is short for Numerical Python. It is a Python library/package used for working with arrays which contains classes, functions, variables , a large library of mathematical functions etc for working with scientific calculation. It can be used to create an \u201cn\u201d dimensional array where \u201cn\u201d is any integer.              </p>"},{"location":"numpy/#why-numpy","title":"Why NumPy","text":"<p>In Python we have lists that serve the purpose of arrays, but they are slow. NumPy aims to provide an array object that is up to 50x faster than a traditional Python list.</p> <p></p> <p>The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy. Arrays are very frequently used in data science, where speed and resources are very important.     </p> <p></p> <p>What makes NumPy arrays faster than lists: NumPy arrays are stored at one continuous place in memory unlike lists, so processes can access and manipulate them very efficiently. This behavior is called locality of reference. This is the main reason why NumPy is faster than lists. It is also optimized to work with the latest CPU architectures.</p>"},{"location":"numpy/#installing-numpy","title":"Installing NumPy","text":"<p>To install NumPy, you can use pip, the Python package installer. Open your terminal or command prompt and enter the following command:</p> <pre><code>pip3 install numpy\n</code></pre>"},{"location":"numpy/#importing-numpy","title":"Importing NumPy","text":"<p>There are two ways to import NumPy. Code Example : </p> <pre><code># this will import the entire NumPy module.\nimport numpy as np\n# this will import all class, objects, variables etc from the NumPy package   \nfrom numpy import*  \n</code></pre> <p>NumPy is usually imported under the np alias. </p> <p></p> <p>alias: In Python aliases are an alternate name for referring to the same thing. </p> <p></p>"},{"location":"numpy/#creating-numpy-arrays","title":"Creating NumPy Arrays","text":"<p>The array object in NumPy is called ndarray. We can create a NumPy ndarray object by using the array() function. NumPy arrays can be created in a number of ways. Here are some of the most common methods:</p> <ul> <li>Using the numpy.array() function to create an array from a list/tuple:</li> </ul> <pre><code>a = np.array([1, 2, 3])\n</code></pre> <ul> <li>Using the numpy.zeros() function to create an array filled with zeros:</li> </ul> <pre><code>b = np.zeros((2, 3))\n</code></pre> <ul> <li>Using the numpy.ones() function to create an array filled with ones:</li> </ul> <pre><code>c = np.ones((2, 3))\n</code></pre> <ul> <li>Using the numpy.random.randint(): Returns an array of random integers between the two given numbers</li> </ul> <pre><code>d = np.random.randint(0, 10)\n</code></pre> <ul> <li>Using the numpy.random.rand() function to create an array of random values:</li> </ul> <pre><code>e = np.random.rand(2, 3)\n</code></pre>"},{"location":"numpy/#numpy-array-dimensions","title":"NumPy Array Dimensions","text":"<p>A dimension in arrays is one level of array depth (nested arrays). nested array: are arrays that have arrays as their elements. 0-D Arrays 1-D Arrays 2-D Arrays 3-D Arrays.</p> <p></p> <p>0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array. </p> <p></p> <p>Code Example:</p> <pre><code>arr=np.array(30) \nprint (arr)\n</code></pre> <p>An array that has 0-D arrays as its elements is called a uni-dimensional or 1-D array. These are the most common types of arrays. </p> <p></p> <p>Code Example :</p> <pre><code> arr=np.array([30,35,38,40,46,52])\n print (arr)\n</code></pre> <p>An array that has 1-D arrays as its elements is called a 2-D array. These are often used to represent matrix or 2nd order tensors. </p> <p></p> <p>Code Example :</p> <pre><code>arr=np.array([[30,35,38,40,46,52],[22,28,39,42,49,52]])\n print (arr)\n</code></pre> <p>An array that has 2-D arrays (matrices) as its elements is called 3-D array. These are often used to represent a 3rd order tensor. </p> <p></p> <p>Code Example : </p> <pre><code>arr=np.array([[[30,35,38,40,46,52],[22,28,39,42,49,52], [71,24,88,64,31,94]]])\nprint (arr)\n</code></pre> <p>NumPy Arrays provides the ndim attribute that returns an integer that tells us how many dimensions the array has. </p> <p></p> <p>Code Example :</p> <pre><code>arr=np.array([[[30,35,38,40,46,52],[22,28,39,42,49,52], [71,24,88,64,31,94]]])\nprint (arr.ndim)\n</code></pre> <p>An array can have any number of dimensions. When the array is created, you can define the number of dimensions by using the ndim argument. </p> <p></p> <p>Code Example : </p> <pre><code>arr=np.array([1,2,3,4],ndmin=6)\nprint (arr.ndim)\nprint (\u201cNumber of dimensions:\u201d, arr.ndim)\n</code></pre>"},{"location":"numpy/#arrays-type-and-shape","title":"Arrays type and shape","text":"<p>NumPy Array Data Type :The NumPy array object has a property called dtype that returns the data type of the array.</p> <p></p> <p>Code Example :</p> <pre><code>arr=np.array([1,2,3,4,5]) \nprint (arr.dtype)\n</code></pre> <p>NumPy Array Shape : The shape of an array is the number of elements in each dimension. NumPy arrays have an attribute called shape that returns a tuple with each index having the number of corresponding elements</p> <p></p> <p>Code example :</p> <pre><code>arr=np.array([1,2,3,4,5,6])\nprint (arr.shape)\n</code></pre>"},{"location":"numpy/#numpy-array-indexing","title":"NumPy Array Indexing","text":"<p>Array indexing is the same as accessing an array element. You can access an array element by referring to its index number. The indexes in NumPy arrays start with 0, meaning that the first element has index 0, and the second has index 1 etc.</p> <p></p> <p>Code Example : </p> <pre><code>arr=np.array([1,2,3,4])\nprint (arr[0])\n</code></pre> <p>To access elements from 2-D arrays we can use comma separated integers representing the dimension and the index of the element.</p> <p></p> <p>Code Example :</p> <pre><code>arr=np.array([[1,2,3,4],[4,3,2,1]])\nprint (arr[0][1])\n\n</code></pre> <p>To access elements from 3-D arrays we can use comma separated integers representing the dimensions and the index of the element. </p> <p></p> <p>Code Example : </p> <pre><code>arr=np.array([1,2,3,4],[4,3,2,1],[8,6,7,9])\nprint (arr[0][1][0])\n</code></pre> <p>Use negative indexing to access an array from the end Code Example</p> <pre><code>arr=np.array([1,2,3,4],[4,3,2,1],[8,6,7,9])\nprint (arr[0][-1][-2])\n</code></pre>"},{"location":"numpy/#numpy-array-slicing","title":"NumPy Array Slicing","text":"<p>Slicing in python means taking elements from one given index to another given index. We pass slice instead of index like this [start: end]. We can also define the step, like this [start:end:step].</p> <ul> <li>If we don't pass start its considered 0</li> <li>If we don't pass end its considered length of array in that dimension</li> <li>If we don't pass step its considered 1</li> </ul> <p>Note: The result includes the start index, but excludes the end index. Use the minus operator to refer to an index from the end.</p> <p></p> <p>Code Example :</p> <pre><code>arr=np.array([1,2,3,4,5])\nprint (arr[0:5]) #slice arrays from index 0 to 5 excluding 5 print (arr[:4]) #slice from beginning to 4 excluding 4\nprint (arr[2:]) #slice from index 2 onwards\nprint (arr[:-3]) #slice from index -3\n</code></pre> <p>Code Example :</p> <pre><code>arr=np.array([1,2,3,4,5])\nprint (arr[:4:1]) #slice from beginning to 4 step of 1 print (arr[0::3]) #slice from index 0 onwards step of 3 print (arr[:-1:2]) #slice from index -1 step of 2\n</code></pre>"},{"location":"numpy/#array-operations-in-numpy","title":"Array Operations in NumPy","text":"<p>Element-wise Operations : NumPy allows you to perform element-wise operations on arrays. Here are some examples:</p> <pre><code>a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\n\n# Element-wise addition\nc = a + b\nprint(c)  # Output: [5 7 9]\n\n# Element-wise multiplication\nd = a * b\nprint(d)  # Output: [ 4 10 18]\n</code></pre> <p>Matrix Multiplication : NumPy allows you to perform matrix multiplication using the numpy.dot() function. Here is an example:</p> <pre><code>a = np.array([[1, 2], [3, 4]])\nb = np.array([[5, 6], [7, 8]])\n\n# Matrix multiplication\nc = np.dot(a, b)\nprint(c)\n</code></pre> <p>NumPy Array Reshaping : Reshaping means changing the shape of an array. The shape of an array is the number of elements in each dimension. By reshaping we can add or remove dimensions or change number of elements in each dimension.</p> <p></p> <p>Code Example :</p> <pre><code># we can do it this way\narr=np.array([1,2,3,4,5,6,7,8,9,10])\narr2= arr.reshape(5,2)\nprint (arr)\nprint (arr2)\n# or this way\na = np.array([1, 2, 3, 4, 5, 6])\nb = np.reshape(a, (2, 3))\nprint (a)\nprint (b)\n</code></pre> <p>Transposing Arrays : NumPy provides a way to transpose arrays using the numpy.transpose() function. Here is an example:</p> <pre><code>a = np.array([[1, 2], [3, 4], [5, 6]])\nb = np.transpose(a)\nprint(b)\n</code></pre> <p>Aggregation Functions : NumPy provides several aggregation functions that can be used to compute statistics on arrays. Here are some examples:</p> <pre><code>a = np.array([1, 2, 3, 4, 5])\n\n# Computing the sum of the elements in the array\nprint(np.sum(a))  # Output: 15\n\n# Computing the mean of the elements in the array\nprint(np.mean(a))  # Output: 3.0\n\n# Computing the standard deviation of the elements in the array\nprint(np.std(a))  # Output: 1.41421356\n</code></pre>"},{"location":"numpy/#numpy-array-copy-and-view","title":"NumPy Array Copy and View","text":"<p>The main difference between a copy and a view of an array is that the copy is a new array, and the view is just a view, or link to, the original array.</p> <p></p> <p>The copy owns the data and any changes made to the copy will not affect original array, and any changes made to the original array will not affect the copy.</p> <p></p> <p>The view does not own the data and any changes made to the view will affect the original array, and any changes made to the original array will affect the view.</p> <p></p> <p>As mentioned, copies owns the data, and views does not own the data, so how can we check if it owns the data or not?</p> <p></p> <p>Every NumPy array has the attribute base that returns None if the array owns the data. Otherwise, the base attribute refers to the original object</p> <p></p> <p>Code example :</p> <pre><code>import numpy as np\narr=np.array([1,2,3,4,5,6])\narrview=arr.view() #creates a view of the array arrcopy=arr.copy() #creates a copy of the array\nprint (arrview.base) #check if the array owns its data print (arrcopy.base) #check if the array owns its data (should output none)\n</code></pre> <p>Documentations NumPy</p>"},{"location":"oop/","title":"Object Oriented Programming in Python","text":""},{"location":"oop/#introduction","title":"Introduction","text":"<p>In the last chapter we learnt the basics of programming, you were shown how to store data in data structures such as lists, strings, integers, dictionaries, and others. And you were shown how to create behavior for your program using keywords, and later using functions to group these keywords. This coding approache is called Logic Programming.</p> <p></p> <p>However, there are different approaches or perspectives in computer programming which we call programming paradigms. They provide various ways of organizing and structuring code to solve a particular problem.</p> <p></p> <p>Each paradigm has its own strengths, weaknesses, and suitability for different types of problems and use cases. Some programming languages may support multiple paradigms, while others may have limited support for one specific paradigm.</p> <p></p> <p>In this course we will get to know the object-oriented programming (OOP), a programming paradigm widely used in Python.</p> <p></p> <p>PS: At this stage of the course, we assume that you know the basics of Python.</p>"},{"location":"oop/#object-oriented-programming-oop","title":"Object-oriented programming (OOP)","text":""},{"location":"oop/#what-is-it","title":"What is it ?","text":"<p>Object-oriented programming (OOP) is an approach that organizes software design based on objects, which are data fields with unique attributes and behaviors, instead of functions and logic. </p>"},{"location":"oop/#why-we-use-it","title":"Why we use it ?","text":"<p>One of the main benefits of OOP is its organization, which makes it easier for developers to collaborate on a project by dividing it into smaller groups. Additionally, OOP offers several other advantages, such as code reusability, scalability, and efficiency.</p>"},{"location":"oop/#oop-basic-concepts","title":"OOP Basic Concepts","text":"<ul> <li> <p>Class: A class is a blueprint for creating objects. It defines a set of attributes (properties) and methods (functions) that the objects created from the class will have. For example, you could create a \"Person\" class with attributes like name, age, and address, and methods like \"introduce\" and \"greet\".</p> </li> <li> <p>Object: An object is an instance of a class. When you create an object from a class, you get a specific \"realization\" of the class, with its own set of attributes and methods. For example, you could create two \"Person\" objects, \"John\" and \"Jane\", each with their own name, age, and address.</p> </li> <li> <p>Attributes: Attributes are the properties or characteristics of an object. They define the state of the object. In the example of the \"Person\" class, the attributes would be name, age, and address.</p> </li> <li> <p>Methods: Methods are the actions or behaviors of an object. They define what the object can do. In the example of the \"Person\" class, the methods would be \"introduce\" and \"greet\".</p> </li> </ul> <p>Here is a simple example of a Python class that defines a \"Person\" object:</p> <pre><code>class Person:\n    def __init__(self, name, age, address):\n        self.name = name\n        self.age = age\n        self.address = address\n\n    def introduce(self):\n        return f\"Hi, my name is {self.name} and I am {self.age} years old.\"\n\n    def greet(self, other_person):\n        return f\"Hello {other_person.name}, it's nice to meet you!\"\n</code></pre> <p>And here is how you can create objects from the \"Person\" class and use their attributes and methods:</p> <pre><code>john = Person(\"John\", 30, \"123 Main St.\")\njane = Person(\"Jane\", 25, \"456 Elm St.\")\n\nprint(john.introduce())  # Output: Hi, my name is John and I am 30 years old.\nprint(jane.greet(john))  # Output: Hello John, it's nice to meet you!\n</code></pre>"},{"location":"oop/#when-to-use-it","title":"When to use it ?","text":"<ul> <li> <p>Modeling real-world objects: You can create classes to model real-world objects in Python, such as dogs, cars, or books. For example, you can create a \"Dog\" class with properties like breed, name, and age, and methods like \"bark\", \"eat\", and \"sleep\". This makes it easier to manipulate and work with instances of the class, and to keep track of the state of each object.</p> </li> <li> <p>Building games: OOP is often used in game development to model game objects and their behaviors. For example, you can create a \"Player\" class to represent a player in a game, with properties like position, health, and score, and methods like \"move\", \"attack\", and \"jump\".</p> </li> <li> <p>Database applications: You can use OOP to interact with databases in Python. For example, you can create a \"Record\" class to represent a record in a database table, with properties like id, name, and date, and methods like \"insert\", \"update\", and \"delete\".</p> </li> <li> <p>Web development: OOP is commonly used in web development to build applications and services. For example, you can create a \"User\" class to represent a user of your application, with properties like name, email, and password, and methods like \"register\", \"login\", and \"logout\".</p> </li> <li> <p>Scientific simulations: OOP can be used to create scientific simulations, such as physical simulations or financial models. For example, you can create a \"Particle\" class to represent a particle in a physical simulation, with properties like position, velocity, and mass, and methods like \"move\", \"collide\", and \"absorb\".</p> </li> </ul> <p>These are just a few examples of how OOP can be used in Python. With its powerful and flexible object-oriented features, OOP is a widely used paradigm in Python and can be applied to many different types of projects.</p>"},{"location":"oop/#some-examples","title":"Some examples","text":"<ul> <li>Car: Create a class Car that represents a car. The class should have properties brand, model, and year, and a method drive that makes the car drive (print \"Driving the car !\").</li> </ul> <pre><code>## Class implementation\nclass Car:\n    def __init__(self, brand, model, year):\n        self.brand = brand\n        self.model = model\n        self.year = year\n\n    def drive(self):\n        print(\"Driving the car !\")\n\n## Object declaration\ncar = Car(\"Toyota\", \"Camry\", 2020)\n\nprint(car.drive())\n# Output: Driving the car !\n\n</code></pre> <ul> <li>Dog: Create a class Dog that represents a dog. The class should have properties name, breed, and age, and a method bark that makes the dog bark (print \"Woof!\").</li> </ul> <pre><code>## Class implementation\nclass Dog:\n    def __init__(self, name, breed, age):\n        self.name = name\n        self.breed = breed\n        self.age = age\n\n    def bark(self):\n        print(\"Woof!\")\n\n## Object declaration\ndog = Dog(\"Max\", \"Labrador\", 5)\nprint(dog.bark())\n# Output: Woof!\n</code></pre> <p>Let's code !</p>"},{"location":"oop/#operator-overloading","title":"Operator overloading","text":"<p>Operator overloading allows objects of user-defined classes to behave like built-in data types. This means that you can use familiar syntax for objects of your classes, making your code more intuitive and easier to read.</p> <p></p> <p>For example, consider a class for a 2D point:</p> <pre><code>class Point2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n</code></pre> <p>This class defines a 2D point, with x and y coordinates. You can create instances of the class and display them:</p> <pre><code>p1 = Point2D(1, 2)\nprint(p1)  # Output: (1, 2)\n</code></pre> <p>Now, if you want to add two points, you can overload the addition operator + by defining the __add__ method:</p> <pre><code>class Point2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n    def __add__(self, other):\n        return Point2D(self.x + other.x, self.y + other.y)\n</code></pre> <p>With this change, you can now add two points:</p> <pre><code>p1 = Point2D(1, 2)\np2 = Point2D(3, 4)\np3 = p1 + p2\nprint(p3)  # Output: (4, 6)\n</code></pre> <p>In this example, the __add__ method takes another Point2D object as its argument and returns a new Point2D object that represents the sum of the two points. This allows you to use the + operator with instances of your class, just like you would with built-in data types.</p> <p></p> <p>You can also overload other operators, such as -, *, /, &lt;, &gt;, and so on, by defining the corresponding special methods, such as __sub__, __mul__, __truediv__, __lt__, __gt__, and so on. </p> <p></p> <p>Here's an example that overloads the subtraction operator:</p> <pre><code>class Point2D:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n    def __add__(self, other):\n        return Point2D(self.x + other.x, self.y + other.y)\n\n    def __sub__(self, other):\n        return Point2D(self.x - other.x, self.y - other.y)\n</code></pre> <p>With this change, you can now subtract two points:</p> <pre><code>p1 = Point2D(1, 2)\np2 = Point2D(3, 4)\np3 = p1 - p2\nprint(p3)  # Output: (-2, -2)\n</code></pre>"},{"location":"oop/#cheat-sheet-for-class-special-methods","title":"Cheat sheet for Class Special Methods:","text":"Operator Method String representation __str__ Addition (+) __add__ Subtraction (-) __sub__ Multiplication (*) __mul__ Power (**) __pow__ Division (/) __truediv__ Floor Division (//) __floordiv__ Remainder (modulo)(%) __mod__ Lesser than (&lt;) __lt__ Greater than (&gt;) __gt__ Lesser than or equal (&lt;=) __le__ Greater than or equal (&gt;=) __ge__ Equal (==) __eq__ Not equal (!=) __ne__ Absolute value (abs()) __abs__ Bitwise AND(&amp;) __and__ Bitwise OR (|) __or__ Bitwise NOT(~) __invert__"},{"location":"oop/#inheritance-in-object-oriented-programming","title":"Inheritance in Object-Oriented Programming","text":""},{"location":"oop/#what-is-it_1","title":"What is it ?","text":"<p>Inheritance is a mechanism in Object-Oriented Programming (OOP) that allows a new class to be defined based on an existing class. The new class, known as the subclass, inherits attributes and behavior from the existing class, known as the superclass. This enables code reuse, allowing new classes to be defined with little or no modifications to the existing classes.</p> <p>For example, consider a superclass called Animal which has attributes such as name, species, and age, and a method called make_sound() that returns the sound the animal makes. We can create a subclass of Animal called Dog which inherits all of the attributes and behavior of the Animal class. We can also add additional attributes specific to dogs such as breed and override the make_sound() method to return the specific sound a dog makes, like \"bark\".</p> <pre><code>class Animal:\n    def __init__(self, name, species, age):\n        self.name = name\n        self.species = species\n        self.age = age\n\n    def make_sound(self):\n        return \"Sound made by the animal\"\n\nclass Dog(Animal):\n    def __init__(self, name, breed, age):\n        Animal.__init__(self, name, \"Dog\", age)\n        self.breed = breed\n\n    def make_sound(self):\n        return \"Bark\"\n\ndog = Dog(\"Rufus\", \"Labrador\", 5)\nprint(dog.name) # Rufus\nprint(dog.species) # Dog\nprint(dog.age) # 5\nprint(dog.breed) # Labrador\nprint(dog.make_sound()) # Bark\n\n</code></pre> <p>In this example, the Dog class inherits the attributes name, species, and age from the Animal class and also adds an additional attribute breed. The method make_sound() is also overridden in the Dog class to return a specific sound for dogs.</p> <p>Inheritance provides a way to model relationships between classes, and is an important concept in OOP for code reuse and organization. In Python, inheritance is an is-a relationship. That is, we use inheritance only if there exists an is-a relationship between two classes. For example,</p> <ul> <li>Car is a Vehicle</li> <li>Student is a Person</li> <li>Cat is an Animal</li> </ul> <p>Here, Car can inherit from Vehicle, Apple can Student from Person, and so on.</p>"},{"location":"oop/#polymorphism-and-abstraction","title":"Polymorphism and Abstraction","text":"<ul> <li> <p>Polymorphism : Is the ability of an object to take on multiple forms. It allows objects of different classes to be treated as objects of the same class. This means that you can write a single function or method that can work with objects of different classes, as long as they implement the same interface.</p> </li> <li> <p>Abstraction : Is a technique that allows you to simplify complex systems by ignoring irrelevant details and focusing on the essential features of an object. It is achieved by defining an interface that exposes the essential features of an object, while hiding the implementation details.</p> </li> </ul> <p>Here's an example in Python to demonstrate the difference between polymorphism and abstraction:</p> <pre><code>from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return 3.14 * self.radius * self.radius\n\ndef print_area(shape):\n    print(shape.area())\n\nrect = Rectangle(10, 20)\ncirc = Circle(5)\n\nprint_area(rect) # 200\nprint_area(circ) # 78.5\n\n</code></pre> <p>In this example, the Shape class serves as an abstract class and defines an abstract method area. The Rectangle and Circle classes inherit from Shape and provide their own implementation of the area method. </p> <p></p> <p>This demonstrates polymorphism, as objects of different classes (Rectangle and Circle) can be treated as objects of the same class (Shape). The print_area function demonstrates polymorphism, as it can accept objects of different classes (Rectangle and Circle) as long as they implement the same interface (area method).</p> <p></p> <p>At the same time, the Shape class demonstrates abstraction by defining an interface that exposes the essential features of a shape, while hiding the implementation details. The Rectangle and Circle classes implement the area method, but the details of the implementation are hidden from the user. The user only sees the essential features of the object (the area method).</p>"},{"location":"oop/#multiple-and-multilevel-inheritance","title":"Multiple and Multilevel Inheritance","text":"<ul> <li> <p>Multiple Inheritance: is a feature of Object Oriented Programming (OOP) languages where a class can inherit properties and attributes from more than one parent class. This means that a single class can have multiple base classes and it can inherit properties and attributes from all of them. </p> <p>For example, consider a scenario where you have two classes: Shape and Color. The class Shape defines the properties of a 2-D shape such as its area, perimeter, etc. The class Color defines the color of an object. Now, you want to create a new class Rectangle which is a shape and has a color. You can achieve this by using multiple inheritance. </p> </li> </ul> <p>Here's an example implementation in Python:</p> <pre><code>class Shape:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nclass Color:\n    def __init__(self, color):\n        self.color = color\n\nclass Rectangle(Shape, Color):\n    pass\n\nrect = Rectangle(10, 20, 'red')\nprint(rect.area())\nprint(rect.perimeter())\nprint(rect.color)\n</code></pre> <p>In this example, the class Rectangle inherits from both Shape and Color classes. This means that it has all the attributes and methods defined in both the classes.</p> <p></p> <ul> <li> <p>Multilevel Inheritance : is a type of inheritance where a class inherits properties and attributes from its parent class, and the parent class inherits from its parent class, and so on.</p> <p>For example, consider a scenario where you have a class Animal which defines basic properties of an animal such as its name, age, and breed. Another class Mammal inherits from Animal class and adds new properties such as type of fur, etc. Finally, a new class Cat is created which inherits from Mammal class and adds new properties specific to cats such as the type of meow, etc. </p> </li> </ul> <p>Here's an example implementation in Python:</p> <pre><code>class Animal:\n    def __init__(self, name, age, breed):\n        self.name = name\n        self.age = age\n        self.breed = breed\n\nclass Mammal(Animal):\n    def __init__(self, name, age, breed, fur_type):\n        Animal.__init__(self, name, age, breed)\n        self.fur_type = fur_type\n\nclass Cat(Mammal):\n    def __init__(self, name, age, breed, fur_type, meow_type):\n        Mammal.__init__(self, name, age, breed, fur_type)\n        self.meow_type = meow_type\n\ncat = Cat('Tom', 3, 'Siamese', 'short hair', 'loud')\nprint(cat.name)\nprint(cat.age)\nprint(cat.breed)\nprint(cat.fur_type)\nprint(cat.meow_type)\n</code></pre> <p>In this example, the class Cat inherits from the class Mammal which in turn inherits from the class Animal. This creates a hierarchy of classes where each class inherits properties and attributes from its parent class.</p>"},{"location":"pd/","title":"Pandas: Understanding & working with Pandas","text":""},{"location":"pd/#pandas","title":"Pandas","text":"<p>Pandas is a Python library used for working with data sets. It has functions for analyzing, cleaning, exploring, and manipulating data. The name \"Pandas\" has a reference to both \"Panel Data\", and \"Python Data Analysis\" and was created by Wes McKinney in 2008</p> <p></p> <p>Pandas allows us to :</p> <ul> <li>Analyze big data and make conclusions based on statistical theories.</li> <li>Clean messy data sets, and make them readable and relevant. Relevant data is very important in data science. </li> <li>Pandas gives you answers about the data Such as : Is there a correlation between two or more columns? What is the average value?Max value? Min value?</li> <li>Manage diffrent data sets merging them filtering them etc...</li> </ul> <p></p> <p>Pandas is also able to delete rows that are not relevant, or contain wrong values, like empty or NULL values. This is called cleaning the data.</p> <p></p> <p>There are two ways to import pandas : </p> <pre><code>import pandas #This will import the entire pandas module.\n\nfrom pandas import* # This will import all class, objects, variables etc. from pandas package\n</code></pre>"},{"location":"pd/#pandas-series","title":"Pandas Series","text":"<p>A Pandas Series is like a column in a table. It is a one-dimensional array holding data of any type</p> <pre><code>import pandas as pd\ndataset1=[1,2,3]\ndf1=pd.Series(dataset1)\nprint (df1)\n</code></pre>"},{"location":"pd/#pandas-labels","title":"Pandas Labels","text":"<p>If nothing else is specified, the values are labeled with their index number. The first value has index 0, etc. This label can be used to access a specified value. With the index argument, you can name your own labels. When using labels, you can access an item by using the label. Code example : </p> <pre><code>import pandas as pd\ndataset1=[1,2,3]\ndf1=pd.Series(dataset1, index=[\"a\",\"b\",\"c\"])\nprint (df1)                     \nprint (df1[\"a\"])\n</code></pre>"},{"location":"pd/#pandas-key-value-objects","title":"Pandas Key Value objects","text":"<p>We can also use key/value pair objects like dictionaries when creating a Series</p> <p></p> <p>Note: The keys of the dictionary become the labels</p> <p></p> <p>Code example :</p> <pre><code>import pandas as pd\ndataset1={\"Vehicle number\":1, \"Wheels\":4, \"Doors\":4}\ndf1=pd.Series(dataset1)\nprint (df1)\n</code></pre>"},{"location":"pd/#pandas-data-frames","title":"Pandas Data Frames","text":"<p>Data sets in Pandas are usually multi-dimensional tables, called DataFrames. Series can be considered to be like a column in a table, whereas a DataFrame can be considered to be the table. </p> <p></p> <p>We can use the loc attribute to locate one or more rows. Just as with series, we can name indexes of data frames and locate them using the loc attribute</p> <p></p> <p>Code example :</p> <pre><code>import pandas as pd\ndataset1={\"Vehicle number\":[1,2,3], \"Wheels\":[4,2,4], \"Doors\":[4,0,5]}\ndf1=pd.DataFrame(dataset1, index=[\"Car\",\"Motorcycle\",\"Van\"])\nprint(df1)\nprint (df1.loc[\"Car\"])              \n</code></pre>"},{"location":"pd/#reading-csv-files-with-pandas","title":"Reading CSV Files with Pandas","text":"<p>A simple way to store big data sets is to use CSV (Comma Separated Value) files. CSV files contain plain text and are a well know format that can be read by almost all software including Pandas</p> <p></p> <p>If your data sets are stored in a file, Pandas can load them into a DataFrame. Code example :</p> <pre><code>import pandas as pd \ndataframe1=pd.read_csv(\u2018data.csv\u2019)\nprint(dataframe1.to_string())\n</code></pre>"},{"location":"pd/#getting-a-quick-overview-of-the-dataframes-content","title":"Getting a quick overview of the Dataframes content","text":"<ul> <li> <p>One of the most used method for getting a quick overview of the DataFrame, is the head() method. The head() method returns the headers and a specified number of rows, starting from the top. </p> </li> <li> <p>The tail() method returns the last rows of the DataFrame</p> </li> <li> <p>The DataFrame object has a method called info(), that gives you more information about the data set.</p> </li> </ul> <p>Code Example :</p> <pre><code>import pandas as pd \ndataframe1=pd.read_csv(\"data.csv\") \nprint (dataframe1.head())\nprint (dataframe1.tail()) \ndataframe1.info()\n</code></pre>"},{"location":"pd/#data-cleaning-with-pandas","title":"Data Cleaning With pandas","text":"<p>Data cleaning means fixing bad data in your data set Examples of bad data include : </p>"},{"location":"pd/#empty-cells","title":"Empty cells","text":"<p>Empty cells can potentially give you a wrong result when you analyze data. One way to deal with empty cells is to remove rows that contain empty cells. This usually works since data sets can be very large, and removing a few rows will not have a significant impact on the results.</p> <p></p> <p>To remove empty cells, we can use the dropna() method. By default, the dropna() method returns a new DataFrame, and will not change the original. If you want to change the original DataFrame, use the inplace = True argument. Code Example :</p> <pre><code>import pandas as pd                     \ndataframe1=pd.read_csv(\"data.csv\")\nprint (dataframe1)\ndataframe1.dropna(inplace=True)\nprint (dataframe1)\n</code></pre> <p>Another way of dealing with empty cells is to insert a new value to replace the empty cell. This way you do not have to delete entire rows just because of some empty cells. The fillna() method allows us to replace empty cells with a value. To only replace empty values for one column, specify the column name for the DataFrame. Code Example :</p> <pre><code>import pandas as pd\ndataframe1=pd.read_csv(\"data.csv\")\ndataframe1.fillna(130, inplace=True)\ndataframe1[\"Calories\"].fillna(130, inplace=True)\nprint(dataframe1.to_string())\n</code></pre> <p>You can also fill in empty cells with the mean, median or mode of the column. Pandas uses the mean() median() and mode() methods to calculate the respective values for a specified column</p> <ul> <li>Mean : the mean is the average value (the sum of all values divided by number of values)</li> <li>Median : the median is the value in the middle, after you have sorted all values ascending</li> <li>Mode : the mode is the value that appears most frequently</li> </ul> <p>Code Example : </p> <pre><code>import pandas as pd\n\ndataframe1=pd.read_csv(\"data.csv\")\n\nmeancal=dataframe1[\"Calories\"].mean()\nmediancal=dataframe1[\"Calories\"].median()\nmodecal=dataframe1[\"Calories\"].mode()\n\nprint (\"The mean of calories is\" + str(meancal) + \" The median of calories is \" + str(mediancal) + \" The mode of calories is \" + str(modecal)) \n\nmeandf=dataframe1[\"Calories\"].fillna(meancal)\nmediandf=dataframe1[\"Calories\"].fillna(mediancal)\nmodedf=dataframe1[\"Calories\"].fillna(modecal)\n\nprint(meandf.to_string())\nprint(mediandf.to_string())\nprint(modedf.to_string())\n</code></pre>"},{"location":"pd/#data-in-wrong-format","title":"Data in wrong format","text":"<p>Cells with data of incorrect format can make it difficult, or even impossible, to analyze data.</p> <p></p> <p>To remedy this, you can either remove the rows, or convert all cells in the columns into the same format</p>"},{"location":"pd/#incorrect-data","title":"Incorrect Data","text":"<p>Incorrect data does not have to be empty cells or incorrect format, it can just be incorrect, like if someone entered 199 instead of 1.99. Sometimes you can spot incorrect data by looking at the data set because you have an expectation of what it should be.</p> <p></p> <p>If you take a look at our data set you can see that in row 7 the duration is 450, but for all the other rows the duration is between 30 and 60. It doesn't have to be incorrect, but taking in consideration that this is the data set of someone's workout sessions, we conclude this person did not work out for 450 minutes</p> <p></p> <p>One way to fix wrong values is to replace them with something else. For small data sets you might be able to replace the wrong data one by one, but not for large data sets. To replace wrong data for larger data sets you can create some rules and set some boundaries for legal values, and replace any values that are outside of the boundaries</p> <p></p> <p>Another way of handling incorrect data is to remove the rows that contains incorrect data. This way you do not have to find out what to replace them with, and there is a good chance you do not need them for analysis.</p> <p></p> <p>Code Example</p> <pre><code>import pandas as pd \n\ndataframe1=pd.read_csv(\"data.csv\")\ndataframe2=pd.read_csv(\"data.csv\")\n\nprint(dataframe1.to_string())\nprint(dataframe2.to_string())\n\nfor x in dataframe1.index: #replace all values in duration above 120 with 120 \n    if dataframe1.loc[x, \"Duration\"] &gt; 120:\n        dataframe1.loc[x,\"Duration\"] = 120\n\nfor y in dataframe2.index: #drop all values above 120\n    if dataframe2.loc[y, \"Duration\"] &gt;120:\n        dataframe2.drop(y, inplace = True)\n\nprint(dataframe1.to_string())\nprint(dataframe2.to_string())\n</code></pre>"},{"location":"pd/#wrong-data-duplicates","title":"Wrong data Duplicates","text":"<p>Duplicate rows are rows that have been entered more than once. By taking a look at our test data set, we can assume that row 11 and 12 are duplicates</p> <p></p> <p>To discover duplicates, we can use the duplicated() method The duplicated() method returns a Boolean values for each row To remove duplicates, use the drop_duplicates() method. Code Example :</p> <pre><code>import pandas as pd\ndataframe1=pd.read_csv(\"data.csv\")\n\nprint(dataframe1.duplicated()) #search for duplicates and output true when found \n\ndataframe1.drop_duplicates(inplace = True) #drop all duplicates\n\nprint(dataframe1.to_string()) #find and drop duplicates example\n</code></pre>"},{"location":"pd/#data-analysis-in-pandas","title":"Data Analysis in Pandas","text":""},{"location":"pd/#correlation-in-pandas","title":"Correlation in Pandas","text":"<p>The corr() method calculates the relationship between each column in your data set. The corr() method ignores \"not numeric\" columns. Code Example : </p> <pre><code>import pandas as pd\ndataframe1=pd.read_csv(\"data.csv\") \ndataframe1.corr()\n</code></pre> <p></p> <p>The Result of the corr() method is a table with a lot of numbers that represents how well the relationship is between two columns. The number varies from -1 to 1 such as :</p> <ul> <li> <p>1 means that there is a 1 to 1 relationship (a perfect correlation), and for this data set, each time a value went up in the first column, the other one went up as well.</p> </li> <li> <p>0.9 is also a good relationship, and if you increase one value, the other will probably increase as well.</p> </li> <li> <p>-0.9 would be just as good relationship as 0.9, but if you increase one value, the other will probably go down</p> </li> <li> <p>0.2 means NOT a good relationship, meaning that if one value goes up does not mean that the other will</p> </li> </ul> <p>What is a good correlation? It depends on the use, but I think it is safe to say you have to have at least 0.6 (or -0.6) to call it a good correlation</p> <p></p> <p>Perfect Correlation: We can see that \"Duration\" and \"Duration\" got the number 1.000000, which makes sense, each column always has a perfect relationship with itself.</p> <p>Good Correlation: \"Duration\" and \"Calories\" got a 0.922721 correlation, which is a very good correlation, and we can predict that the longer you work out, the more calories you burn, and the other way around: if you burned a lot of calories, you probably had a long work out</p> <p>Bad Correlation: \"Duration\" and \"Maxpulse\" got a 0.009403 correlation, which is a very bad correlation, meaning that we can not predict the max pulse by just looking at the duration of the work out, and vice versa</p>"},{"location":"plt/","title":"Plt","text":"<p>plt</p>"},{"location":"sns/","title":"Sns","text":"<p>sns</p>"}]}